<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>p3dpy viz</title>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script src="/static/js/three.js"></script>
    <script src="/static/js/OrbitControls.js"></script>
    <script type="module">
      import Stats from '/static/js/stats.module.js';
      import { GUI } from '/static/js/dat.gui.module.js';
      let camera, scene, renderer;
      let pointcloud, geometry, positions, colors;
      const MAX_POINTS = 500000;

      let guiCtrl = function(){
        this.background = "#000000";
        this.message = "";
      };

      let gui = new GUI();
      let guiObj = new guiCtrl();
      gui.addColor( guiObj , 'background' ).onChange(setBackgroundColor);
      gui.add( guiObj, 'message' );

      let stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild( stats.dom );

      init();
      animate();

      let url = window.location;
      let scheme = window.location.protocol === "https:" ? 'wss://' : 'ws://';
      let webSocketUri = scheme + url.host + '/ws';
      let ws = new WebSocket(webSocketUri);
      ws.onmessage = function(msg) {
        let pc = JSON.parse(msg.data);
        let points = pc['test'];
        for (let i = 0; i < points[0].length; i+=1) {
          pointcloud.geometry.attributes.position.array[3 * i] = points[0][i][0] * 1.0e3;
          pointcloud.geometry.attributes.position.array[3 * i + 1] = points[0][i][1] * 1.0e3;
          pointcloud.geometry.attributes.position.array[3 * i + 2] = points[0][i][2] * 1.0e3;
        }
        pointcloud.geometry.attributes.position.needsUpdate = true;
        for (let i = 0; i < points[1].length; i+=1) {
          pointcloud.geometry.attributes.color.array[3 * i] = points[1][i][0];
          pointcloud.geometry.attributes.color.array[3 * i + 1] = points[1][i][1];
          pointcloud.geometry.attributes.color.array[3 * i + 2] = points[1][i][2];
        }
        pointcloud.geometry.attributes.color.needsUpdate = true;
      };
      function wsSend () {
        ws.send("test");
      }
      setInterval(wsSend, 1000);

      function init() {
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.z = 100;

        scene = new THREE.Scene();

        geometry = new THREE.Geometry();
        const material = new THREE.PointsMaterial({size: 1.0, opacity: 1, vertexColors: THREE.VertexColors});
        geometry = new THREE.BufferGeometry();
        positions = new Float32Array( MAX_POINTS * 3 );
        geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        colors = new Uint8Array( MAX_POINTS * 3 );
        geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3, true) );
        pointcloud = new THREE.Points(geometry, material);
        scene.add(pointcloud);

        renderer = new THREE.WebGLRenderer( { antialias: true, canvas: document.querySelector('#myCanvas')} );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // controls
        const controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.minDistance = 100;
        controls.maxDistance = 10000;

        window.addEventListener( 'resize', onWindowResize );

      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        requestAnimationFrame( animate );
        stats.begin();
        renderer.render( scene, camera );
        stats.end();
      }

      function setBackgroundColor(){
        scene.background = new THREE.Color( guiObj.background );
      }
    </script>
</body>
</html>
